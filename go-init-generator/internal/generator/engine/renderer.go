package engine

import (
	"bytes"
	"strings"
	"text/template"

	"go-init-gen/internal/eventdata"
	"go-init-gen/internal/generator/engine/generators/features"
)

// Renderer is responsible for rendering templates
type Renderer interface {
	RenderTemplate(name string, content string, data *eventdata.TemplateEventData) (string, error)
	RenderTemplateWithData(name string, content string, data map[string]interface{}) (string, error)
	AddFuncMap(funcMap template.FuncMap)
	GetFuncMap() template.FuncMap
}

// DefaultRenderer implements the Renderer interface
type DefaultRenderer struct {
	basePath string
	funcMap  template.FuncMap
}

// NewRenderer creates a new template renderer
func NewRenderer(basePath string) Renderer {
	r := &DefaultRenderer{
		basePath: basePath,
		funcMap:  make(template.FuncMap),
	}

	// Add default template functions
	r.funcMap["ToLower"] = strings.ToLower
	r.funcMap["ToUpper"] = strings.ToUpper
	r.funcMap["Title"] = strings.Title
	r.funcMap["ToCamelCase"] = ToCamelCase
	r.funcMap["ToSnakeCase"] = ToSnakeCase
	r.funcMap["ToKebabCase"] = ToKebabCase

	// Add protocol detection helper function
	r.funcMap["hasEndpoint"] = func(endpoints []*eventdata.EndpointEventData, protocol string) bool {
		if endpoints == nil {
			return false
		}

		protocol = strings.ToUpper(protocol)
		for _, endpoint := range endpoints {
			if strings.ToUpper(endpoint.Protocol) == protocol {
				return true
			}
		}
		return false
	}

	// Add pascal case helper
	r.funcMap["pascal"] = func(s string) string {
		return ToCamelCase(s)
	}

	return r
}

// AddFuncMap adds custom functions to the template renderer
func (r *DefaultRenderer) AddFuncMap(funcMap template.FuncMap) {
	for name, fn := range funcMap {
		r.funcMap[name] = fn
	}
}

// RenderTemplate renders a template with the given data
func (r *DefaultRenderer) RenderTemplate(name string, content string, data *eventdata.TemplateEventData) (string, error) {
	// Create a comprehensive variable map for the template
	vars := make(map[string]interface{})

	// Base variables that should always be available
	vars["Name"] = data.Name
	vars["ModuleName"] = data.Name
	vars["ServiceName"] = data.Name
	vars["projectName"] = data.Name

	// Add database info
	vars["Database"] = data.Database

	// Add endpoints info
	vars["Endpoints"] = data.Endpoints

	// Add docker info
	vars["Docker"] = data.Docker

	// Use the centralized features detector
	fs := features.DetectFeatures(data)

	// Create features map from the feature set
	featureFlags := map[string]bool{
		// Protocol flags
		"hasGRPC":    fs.HasGRPC,
		"hasGraphQL": fs.HasGraphQL,
		"hasREST":    fs.HasREST,
		"hasHTTP":    fs.HasHTTP,
		"hasKafka":   fs.HasKafka,

		// Database flags
		"hasDatabase": fs.HasDatabase,
		"hasPostgres": fs.HasPostgres(),
		"hasMySQL":    fs.HasMySQL(),
		"hasMongoDB":  fs.HasMongoDB(),
		"hasRedis":    fs.HasRedis(),
	}

	// Add database type to variables
	if fs.HasDatabase {
		vars["databaseType"] = fs.DatabaseType
	}

	// Add advanced settings if available
	if data.Advanced != nil {
		vars["Advanced"] = data.Advanced

		// Add module path
		if data.Advanced.ModulePath != "" {
			vars["ModulePath"] = data.Advanced.ModulePath
		} else {
			vars["ModulePath"] = "github.com/example/" + data.Name
		}

		// Add service description
		if data.Advanced.ServiceDescription != "" {
			vars["ServiceDescription"] = data.Advanced.ServiceDescription
		} else {
			vars["ServiceDescription"] = "A microservice generated by go-init."
		}

		// Add advanced flags
		featureFlags["hasAuth"] = data.Advanced.EnableAuthentication
		featureFlags["hasSwagger"] = data.Advanced.GenerateSwaggerDocs

		// Override protocol flags with Advanced settings if they are true
		if data.Advanced.EnableGRPC {
			featureFlags["hasGRPC"] = true
		}
		if data.Advanced.EnableGraphQL {
			featureFlags["hasGraphQL"] = true
		}
	} else {
		// Default values if Advanced is nil
		vars["ModulePath"] = "github.com/example/" + data.Name
		vars["ServiceDescription"] = "A microservice generated by go-init."
	}

	// Add features to variables
	vars["features"] = featureFlags

	// Parse and execute the template
	tmpl, err := template.New(name).Funcs(r.funcMap).Parse(content)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, vars); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// RenderTemplateWithData renders a template with custom data
func (r *DefaultRenderer) RenderTemplateWithData(name string, content string, data map[string]interface{}) (string, error) {
	// Ensure we have data to work with
	if data == nil {
		data = make(map[string]interface{})
	}

	// Check for required fields and provide defaults if missing
	if _, ok := data["Name"]; !ok {
		if projectName, ok := data["projectName"]; ok {
			data["Name"] = projectName
		} else {
			data["Name"] = "default-service"
		}
	}

	if _, ok := data["ModuleName"]; !ok {
		if name, ok := data["Name"]; ok {
			data["ModuleName"] = name
		} else {
			data["ModuleName"] = "default-module"
		}
	}

	if _, ok := data["ServiceName"]; !ok {
		if name, ok := data["Name"]; ok {
			data["ServiceName"] = name
		} else {
			data["ServiceName"] = "default-service"
		}
	}

	// Create template with error option that returns empty string on missing keys
	// instead of failing with an error
	tmpl, err := template.New(name).Funcs(r.funcMap).Option("missingkey=zero").Parse(content)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// GetFuncMap returns the function map used by the renderer
func (r *DefaultRenderer) GetFuncMap() template.FuncMap {
	return r.funcMap
}
